%% Code Supplement "The hierarchical organization of biology revealed through spectral analysis of genetic variation"

% Mark Zaydman (zaydmanm@wustl.edu)
% Arjun Raman (arjun.raman@wustl.edu)

% 4/2020

% This code will go through the major methodological components of the
% manuscript.
%%%%%%%%%%%%%%%%%%%

clear all;
close all;

tic;
f_size=8;

%% Define non-standard colormaps
    [cmaps]=Nonstandard_Colormaps(100);
    
%% Load raw domain counts matrix (Dij)
% This code chunk will load the structured array Dij into the workspace.
% This array contains two fields: Dij.Data and Dij.Taxonomy.

% Dij.Data: Within Dij.Data, Dij.Data.RawCounts contains the raw domain
% count matrix that was generated by adding the number of annotation of
% PFAM domain j appearing in bacterial reference proteome i within the the
% UniProt database. There are 8224 rows within Dij.Data.RawCounts
% corresponding to the reference proteomes downloaded from Uniprot on
% 5/27/2018. The NCBI taxonomy IDs for each row are found in
% Dij.Data.RowLabels. Columns pertaining to domains annotated in fewer
% than 1% of the proteomes have already been removed leaving 6815 columns
% in Dij. The PFAM IDs corresponding to the columns of Dij.Data.RawCounts
% can be found in Dij.Data.ColLabels.

% Dij.Taxonomy: Within Dij.Taxonomy, Dij.Taxonomy.STRING contains a matrix
% of the NCBI taxonomy strings in Kingdom, Phylum, Class, Order, Family,
% Genus, and Species format. Dij.Taxonomy.Categories contains these column
% labels for the matrix in Dij.Taxonomy.STRING. Dij.Taxonomy.ID contains
% the NCBI Taxonomy IDs for the rows in Dij.Taxonomy.STRING.
% Dij.Taxonomy.SameClade contains a three dimensional array of binary
% matrices. Within each binary matrix, a '1' indicates a pair of proteomes
% sharing an identical taxonometric substring at the level correponding to
% Dij.Taxonomy.STRING{z}, where 'z' is the index along the z dimension of
% the binary matrix within Dij.Taxonomy.SameClade.

    load('Dij.mat'); %Raw counts structure array containing Raw counts matrix


%% Section 1: Performing SVD on Dij

    %Calculations
    [Xij]=Processing_Dij(Dij.Data.RawCounts); %Center and standardizing Dij
    [U,S,V]=svd(Xij); %Performing SVD on Xij
    FractionalVariance=(diag(S).^2)./sum(diag(S).^2); % Computing fractional variance per component
    
       %Fitting power-law distribution to components 1 to 3000
        p = polyfit(log((1:1:3000)'),log(FractionalVariance(1:3000)),1); 
        m = p(1);
        b = exp(p(2));

    %Plots 
    plotDijXij(Dij.Data.RawCounts,Xij,cmaps); % Plots of Dij (Fig. 1a) and Xij (Extended Data Fig. 1a)
    plotUSV(U,S,V,cmaps); %Plots of U,S,V matrices (Extended Data Fig. 1b)
    plotSVDSpectrum(FractionalVariance); %Plot EigenSpectrum
    plotPowerLaw(FractionalVariance,(1:1:6815),100*b*(1:1:6815).^m,m); %Plot Power-law distribution (Fig. 1b)
    
    
%% Section 2:Computing mutual information (MI) shared between SVD components and benchmarks of phylogeny
    
    %The correlations between proteomes (rows of Xij) over components of
    %the SVD spectrum is interrogated by correlating their contributions,
    %or 'projections', onto left Singular vectors. The contributions of
    %each proteome to each left SV is represented by (|U>, y-axes in plot
    %below). The projections for a set of 40 proteomes onto the first 50
    %SVs are shown (top five panels), where these proteomes were radomly
    %selected from the same phylum, class, order, family or genus. The
    %bottom panel shows the projections for a set of 40 randomly selected
    %proteomes. The pearson correlations of projections over windows of 5
    %Svs are shown (dots).
        
        plotProteomeCorrelationsExample(U,Dij);
    
        
    %The benchmarks were bootstrapped to generate an equal set of proteome
    %pairs that belong to the 'same taxa' or 'different taxa' at each level
    %(phylum, class, order, family, genus).
    
        Neg_bs_indices={};
        Pos_bs_indices={};
        for Tax_level=2:1:7
            Neg_tmp = [];
            Pos_tmp = [];
            for bs=1
                [Neg_tmp(bs,:),Pos_tmp(bs,:)]=make_bootstrap(Dij.Taxonomy.SameClade(:,:,Tax_level)); 
            end
            Neg_bs_indices{Tax_level}=Neg_tmp;
            Pos_bs_indices{Tax_level}=Pos_tmp;
        end
        
        
    %The phylogenetic information within windows of SVD components is
    %quantified by computing mutual information (MI) shared between the
    %distributions of pairwise correlations and the bootstrapped NCBI phylogeny
    %benchmarks. In the plots below, the distributions of correlations for
    %pairs of proteomes in the bootstrapped benchmarks are shown as well as
    %their associated MI values.

        quant_bins=-1:0.25:1; %Bins used for discretization of distributions of correlations

        plotProteomeMIExample(quant_bins,Neg_bs_indices,Pos_bs_indices,U,Dij);


%% Section 3 :Computing MI shared between SVD components and benchmarks of protein-protein interactions in E coli K12

    load('Proteomes.mat'); % Load E. coli K12 proteome metadata
    
    % Approximate protein right SV projections by averaging domain
    % projections
        [V_protein] = approxProteinProjections(Proteomes,Dij,V); 
    

    % Create row shuffled protein right SV projections matrix
        V_protein_shuffled=zeros(size(V_protein));
        for row=1:1:length(V_protein(:,1))
            V_protein_shuffled(row,1:6815)=V_protein(row,randperm(6815));
        end

    %The correlations between proteins in E. coli K12 over components of
    %the SVD spectrum is interrogated by correlating their approximated
    %contributions, or 'projections', onto right Singular vectors, which
    %are represented in V_protein. The contributions of each protein to
    %each right SV is represented by (|V_protein>, y-axes in plot below).
    %The projections for the E. coli K12 proteins sharing the GO term
    %"Translation" (GO:0006412, green) and for the proteins in the E. coli K12 F1F0
    %ATPase complex on ECOCYC (F1F0 ATPase, purple) are shown (top). For comparison, the projections of
    %the same proteins in the row shuffled version of V_protein
    %(V_protein_shuffled) are also displayed (middle). Finally, the averaged
    %pairwise pearson correlations over 5 SV windows is plotted (bottom, dots). 
    
        plotPPICorrelationsExample(V_protein,V_protein_shuffled);
    
       
    %The benchmarks of protein-protein interactions in E. coli K12 are
    %bootstrapped to generate an equal sets of interacting and
    %non-interacting protein pairs.
    
        load('Benchmarks.mat');
        fn = fieldnames(Benchmarks);
        Neg_bs_indices={};
        Pos_bs_indices={};
        for benchmark_type=1:1:length(fn)
            for bs=1
                [Neg_bs_indices{benchmark_type}(bs,:),Pos_bs_indices{benchmark_type}(bs,:)]=make_bootstrap(Benchmarks.(fn{benchmark_type}).Data,1,Proteomes.Ecoli.Domains.UniprotGene_PFAM_Matrix); 
            end
        end
        
    
    %The protein-protein interaction information within windows of SVD
    %components is quantified by computing mutual information (MI) shared
    %between the distributions of pairwise protein-protein correlations and
    %the bootstrapped benchmarks of protein-protein interaction in E. coli
    %K12. In the plots below, the distributions of correlations within
    %V_protein (top) or V_protein_shuffled (bottom) for pairs of proteins in
    %the bootstrapped benchmarks (PDB or STRING_Nonbinding) with the
    %associated MI value.
    
        quant_bins=-1:0.25:1; %Bins used for discretization of distributions of correlations

        plotPPIMIExample(quant_bins,Neg_bs_indices,Pos_bs_indices,V_protein,V_protein_shuffled,Dij,fn);


%% Section 4: Predicting classes of protein-protein interactions in E. coli K12 using MI windows or other features
    % WARNING: running this code chunk may take approximately 30 minutes depending on local
    % computing resources
    
    load('IQRs.mat'); %Load IQRs from MI cdfs in Fig. 1d
    
    % Load all features for all protein pairs in the E. coli K12 proteome
        load('Features.mat');
        feature_names=fieldnames(Features);
        
        
    %%% Define 'gold-standard' benchmark

        % Define filters
        Filter_DomOverlap=~(Proteomes.Ecoli.Domains.UniprotGene_PFAM_Matrix*Proteomes.Ecoli.Domains.UniprotGene_PFAM_Matrix'); %Remove pairs with nonunique domains
        Filter_Nan=~isnan(Features.IQRs.Physical); %Remove pairs without a domain
        Filter=triu(Filter_DomOverlap.*Filter_Nan,1); %Define composite filter

        %Generate GS pairs
        [GS_Pairs]=makeGoldStandardSet(Filter,Benchmarks);


    %%% Define training and validation datasets
    
        Percent_training=0.6; %Percentage of gold-standard dataset meant for training
        Oversample_negatives=1000; %Fold oversampling of non-interacting pairs
        rng(1); % for reproducibility of partitioning dataset

        % Partition dataset
        [DataSets]=partitionGSPairs(GS_Pairs,Percent_training,Oversample_negatives);


    %%% Demonstrate extraction of MI windows feature
        Windows={'Phylogeny','STRING_Nonbinding','PDB'}; 

        % Calculating the MI Windows Feature
        MI_Windows={}; %Variable 
        for i=1:1:length(Windows)
            MI_Windows.(Windows{i})=corr((V_protein(:,IQRs.(Windows{i})(1):IQRs.(Windows{i})(2)))');
        end

        % Plot MI windows space for the training and validation datasets
        plotMIWindowsFeature(MI_Windows,DataSets,Windows,IQRs);



    %%% Train and validate RF-models
        num_trees=100; %Number of classification trees in random forest

        %%% Train Models on training dataset and validate against validation
        disp('Training models...');
        for f=1:1:length(feature_names)
            RF_Models.(feature_names{f})=TrainModel(Features,DataSets,num_trees,feature_names{f}); 
        end
        disp('Complete');

        %%% Validate against benchmarks 
        disp('Benchmarking models');
        for f=1:1:length(feature_names)
            thisFeature=feature_names{f};
            RF_Models.(thisFeature).Benchmarking=BenchmarkModels(Features,DataSets,Benchmarks,RF_Models,thisFeature);
        end
        disp('Complete');

        %%% Plot confusion matrices for predicting the validation dataset
        % Here we will plot the confusion matrices for the predictions of the pairs
        % in the validation dataset using models trained on each of the features.
        % The numbers above each column of the confusion matrix indicate the recall
        % for each prediction type. The numbers to the right of each row indicate
        % the precision for each prediction type. The shading of each cell 
        % reflects the fraction each 'true class' for pairs wihin a given predicted
        % class. 

            plotValidationSetCMs(DataSets,Features,RF_Models);




        %%% Plot confusion matrices for the predicting pairs in the various bechmarks
        % Here we will plot the confusion matrices for the predictions of the pairs
        % in the entire STRING_NB, STRING_All, GO, and PDB benchmarks. Formatting
        % is similar to the plot for the validation dataset.

            BMs={'STRING_Nonbinding';'STRING_All';'GO';'PDB'}; 
            toPlotBenchmarkingCMs(BMs,RF_Models,Features);



%% Section 5: Developing a null model of random spectral correlations across a 100 SV window
% In this section we will demonstrate that the null model defined by all by all pairwise
% correlations over a 100 component window is stationary across the SVD
% spectrum and across diverse organisms. 

    %Load V_protein for several organisms
        load('V_protein_matrices.mat');

    %Plot all by all correlations across a window of 100 components
    %centered at four different positions in the SVD spectrum for multiple
    %organisms.
        win_width=100;
        win_centers=[75 200 500 1000];
    
        plotNullModels(win_centers,win_width,V_protein_matrices);

%% Section 6: Characterizing hierarchical biological organization using SCALES
% Finally, we will demonstrate using SCALES to identify pathway
% organization for a protein of interest within an organism of interest.
% Several examples are coded. The default is to produce the spectral depth
% matrix for E. coli motB, but the user can uncomment subsequent lines to
% perform scales on E. coli hisG, S. enterica motB, or B. subtilis motB.

% Alternatively, the user can query any Uniprot accession number for a
% protein that encodes at least one PFAM domain within the proteomes of
% (Uniprot ref proteomes IDs in parentheses) E. coli K12 (UP000000625), S. enterica(UP000038136), or
% B. subtilis (UP000001570) .


% E coli K12 examples 
    OrganismOfInterest = 'Ecoli'; %
    ProteinOfInterest = 'P0AF06'; %E coli motB
   
    %%% Uncomment for E coli hisG
%         OrganismOfInterest = 'Ecoli'; ProteinOfInterest = 'P60757'; %E coli hisG

    %%% Uncomment for S enterica motB
%     OrganismOfInterest = 'Senterica'; ProteinOfInterest = 'A0A0U1G658'; % S enterical motB

    %%% Uncomment for B subtilis motB    
%     OrganismOfInterest = 'Bsubtilis'; ProteinOfInterest = 'P28612'; % B_subtilis motB
    
    [StatisticalPathway,SpectralDepthTable]=SCALES(OrganismOfInterest,ProteinOfInterest,V_protein_matrices,Proteomes);




